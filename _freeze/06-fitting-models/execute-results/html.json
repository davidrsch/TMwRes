{
  "hash": "13a92bc9be1a675134ac1cc4c63e2f91",
  "result": {
    "markdown": "\n\n\n# Creando Modelos con parsnip {#sec-models}\n\nEl paquete <span class=\"pkg\">parsnip</span>, un de los paquetes de R que es parte del metaapaquete <span class=\"pkg\">tidymodels</span>, proporciona una interfaz fluida y estandarizada para una variedad de modelos diferentes. En este capítulo, damos algunas motivaciones sobre por qué una interfaz común es beneficiosa para comprender y construir modelos en la práctica y mostramos cómo usar el paquete <span class=\"pkg\">parsnip</span>.\n\nEspecíficamente, nos centraremos en cómo `fit()` y `predict()` directamente con un objeto <span class=\"pkg\">parsnip</span>, que puede ser una buena opción para algunos problemas de modelado sencillos. El próximo capítulo ilustra un mejor enfoque para muchas tareas de modelado al combinar modelos y preprocesadores en algo llamado un objeto de \"flujo de trabajo\".\n\n## Crear un Modelo {#sec-create-a-model}\n\nUna vez que los datos se han codificado en un formato listo para un algoritmo de modelado, como una matriz numérica, se pueden utilizar en el proceso de construcción del modelo.\n\nSupongamos que nuestra elección inicial fue un modelo de regresión lineal. Esto equivale a especificar que los datos del resultado son numéricos y que los predictores están relacionados con el resultado en términos de pendientes e intersecciones simples:\n\n$$y_i = \\beta_0 + \\beta_1 x_{1i} + \\ldots + \\beta_p x_{pi}$$\n\nSe pueden utilizar diversos métodos para estimar los parámetros del modelo:\n\n-   La *regresión lineal ordinaria* utiliza el método tradicional de mínimos cuadrados para resolver los parámetros del modelo.\n\n-   *Regresión lineal regularizada* añade una penalización al método de mínimos cuadrados para fomentar la simplicidad eliminando predictores y/o reduciendo sus coeficientes hacia cero. Esto se puede ejecutar utilizando técnicas bayesianas o no bayesianas.\n\nEn R, el paquete <span class=\"pkg\">stats</span> se puede utilizar para el primer caso. La sintaxis para la regresión lineal usando la función `lm()` es:\n\n``` r\nmodel <- lm(formula, data, ...)\n```\n\ndonde `...` simboliza otras opciones para pasar a `lm()`. La función *not* tiene una interfaz `x`/`y`, donde podríamos pasar nuestro resultado como `y` y nuestros predictores como `x`.\n\nPara estimar con regularización, el segundo caso, se puede ajustar un modelo bayesiano usando el paquete <span class=\"pkg\">rstanarm</span>:\n\n``` r\nmodel <- stan_glm(formula, data, family = \"gaussian\", ...)\n```\n\nEn este caso, las otras opciones pasadas a través de `...` incluirían argumentos para las distribuciones anteriores de los parámetros, así como detalles sobre los aspectos numéricos del modelo. Al igual que con `lm()`, solo está disponible la interfaz de fórmula.\n\nUn enfoque popular no bayesiano para la regresión regularizada es el modelo <span class=\"pkg\">glmnet</span> [@glmnet]. Su sintaxis es:\n\n``` r\nmodel <- glmnet(x = matrix, y = vector, family = \"gaussian\", ...)\n```\n\nEn este caso, los datos del predictor ya deben estar formateados en una matriz numérica; solo hay un método `x`/`y` y ningún método de fórmula.\n\nTenga en cuenta que estas interfaces son heterogéneas en la forma en que se pasan los datos a la función del modelo o en términos de sus argumentos. El primer problema es que, para ajustar los modelos a diferentes paquetes, los datos deben formatearse de diferentes maneras. `lm()` y `stan_glm()` solo tienen interfaces de fórmula mientras que `glmnet()` no. Para otro tipo de modelos, las interfaces pueden ser aún más dispares. Para una persona que intenta realizar un análisis de datos, estas diferencias requieren la memorización de la sintaxis de cada paquete y pueden resultar muy frustrantes.\n\nPara tidymodels, el enfoque para especificar un modelo pretende ser más unificado:\n\n1.  *Especifique el tipo* de modelo según su estructura matemática (por ejemplo, regresión lineal, random forest, KNN, etc.).\n\n2.  *Especificar motor* para montar el modelo. La mayoría de las veces esto refleja el paquete de software que se debe utilizar, como Stan o <span class=\"pkg\">glmnet</span>. Estos son modelos por derecho propio, y <span class=\"pkg\">parsnip</span> proporciona interfaces consistentes al usarlos como motores para el modelado.\n\n3.  *Cuando sea necesario, declarar el moda* del modelo. El modo refleja el tipo de resultado de la predicción. Para resultados numéricos, el modo es la regresión; para resultados cualitativos, es clasificación.[^06-fitting-models-1] Si un algoritmo modelo solo puede abordar un tipo de resultado de predicción, como la regresión lineal, el modo ya está establecido.\n\n[^06-fitting-models-1]: Tenga en cuenta que <span class=\"pkg\">parsnip</span> restringe la columna de resultados de un modelo de clasificación para que se codifique como un *factor*; el uso de valores numéricos binarios generará un error.\n\nEstas especificaciones se construyen sin hacer referencia a los datos. Por ejemplo, para los tres casos que describimos:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-lin-reg-spec_ac66fa4233abac215b340e617835e758'}\n\n```{.r .cell-code}\nlibrary(tidymodels)\ntidymodels_prefer()\n\nlinear_reg() %>% set_engine(\"lm\")\n## Linear Regression Model Specification (regression)\n## \n## Computational engine: lm\n\nlinear_reg() %>% set_engine(\"glmnet\") \n## Linear Regression Model Specification (regression)\n## \n## Computational engine: glmnet\n\nlinear_reg() %>% set_engine(\"stan\")\n## Linear Regression Model Specification (regression)\n## \n## Computational engine: stan\n```\n:::\n\n\nUna vez que se han especificado los detalles del modelo, la estimación del modelo se puede realizar con la función `fit()` (para usar una fórmula) o con la función `fit_xy()` (cuando sus datos ya están preprocesados). El paquete <span class=\"pkg\">parsnip</span> permite al usuario ser indiferente a la interfaz del modelo subyacente; siempre puedes usar una fórmula incluso si la función del paquete de modelado solo tiene la interfaz `x`/`y`.\n\nLa función `translate()` puede proporcionar detalles sobre cómo <span class=\"pkg\">parsnip</span> convierte el código del usuario a la sintaxis del paquete:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-lin-reg-trans_cc2ecc09c52a008f3d03ab51042cfc88'}\n\n```{.r .cell-code}\nlinear_reg() %>% set_engine(\"lm\") %>% translate()\n## Linear Regression Model Specification (regression)\n## \n## Computational engine: lm \n## \n## Model fit template:\n## stats::lm(formula = missing_arg(), data = missing_arg(), weights = missing_arg())\n\nlinear_reg(penalty = 1) %>% set_engine(\"glmnet\") %>% translate()\n## Linear Regression Model Specification (regression)\n## \n## Main Arguments:\n##   penalty = 1\n## \n## Computational engine: glmnet \n## \n## Model fit template:\n## glmnet::glmnet(x = missing_arg(), y = missing_arg(), weights = missing_arg(), \n##     family = \"gaussian\")\n\nlinear_reg() %>% set_engine(\"stan\") %>% translate()\n## Linear Regression Model Specification (regression)\n## \n## Computational engine: stan \n## \n## Model fit template:\n## rstanarm::stan_glm(formula = missing_arg(), data = missing_arg(), \n##     weights = missing_arg(), family = stats::gaussian, refresh = 0)\n```\n:::\n\n\nTenga en cuenta que `missing_arg()` es solo un marcador de posición para los datos que aún no se han proporcionado.\n\n::: rmdnote\nProporcionamos un argumento de `penalty` (penalización) requerido para el motor glmnet. Además, para los motores Stan y glmnet, el argumento `famiy`(familia) se agregó automáticamente como valor predeterminado. Como se mostrará más adelante en esta sección, esta opción se puede cambiar.\n:::\n\nVeamos cómo predecir el precio de venta de las casas en los datos de Ames en función únicamente de la longitud y la latitud:[^06-fitting-models-2]\n\n[^06-fitting-models-2]: ¿Cuáles son las diferencias entre `fit()` y `fit_xy()`? La función `fit_xy()` siempre pasa los datos tal cual a la función del modelo subyacente. No creará variables ficticias/indicadoras antes de hacerlo. Cuando se usa `fit()` con una especificación de modelo, esto casi siempre significa que se crearán variables ficticias a partir de predictores cualitativos. Si la función subyacente requiere una matriz (como glmnet), creará la matriz. Sin embargo, si la función subyacente usa una fórmula, `fit()` simplemente pasa la fórmula a esa función. Estimamos que el 99% de las funciones de modelado que utilizan fórmulas generan variables ficticias. El otro 1% incluye métodos basados ​​en árboles que no requieren predictores puramente numéricos. Consulte @sec-workflow-encoding para obtener más información sobre el uso de fórmulas en tidymodels.\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-ames-geocodes_ca76a451513d89615be08a1b42b1d93b'}\n\n```{.r .cell-code}\nlm_model <- \n  linear_reg() %>% \n  set_engine(\"lm\")\n\nlm_form_fit <- \n  lm_model %>% \n  # Recuerde que a Sale_Price se le ha aplicado una transformación logarítmica previamente\n  fit(Sale_Price ~ Longitude + Latitude, data = ames_train)\n\nlm_xy_fit <- \n  lm_model %>% \n  fit_xy(\n    x = ames_train %>% select(Longitude, Latitude),\n    y = ames_train %>% pull(Sale_Price)\n  )\n\nlm_form_fit\n## parsnip model object\n## \n## \n## Call:\n## stats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data)\n## \n## Coefficients:\n## (Intercept)    Longitude     Latitude  \n##     -302.97        -2.07         2.71\nlm_xy_fit\n## parsnip model object\n## \n## \n## Call:\n## stats::lm(formula = ..y ~ ., data = data)\n## \n## Coefficients:\n## (Intercept)    Longitude     Latitude  \n##     -302.97        -2.07         2.71\n```\n:::\n\n\n<span class=\"pkg\">parsnip</span> no solo permite una interfaz de modelo coherente para diferentes paquetes, sino que también proporciona coherencia en los argumentos del modelo. Es común que diferentes funciones que se ajustan al mismo modelo tengan diferentes nombres de argumentos. Las funciones del modelo de random forest son un buen ejemplo. Tres argumentos comúnmente utilizados son la cantidad de árboles en el conjunto, la cantidad de predictores para muestrear aleatoriamente con cada división dentro de un árbol y la cantidad de puntos de datos necesarios para realizar una división. Para tres paquetes R diferentes que implementan este algoritmo, esos argumentos se muestran en @tbl-rand-forest-args.\n\n\n::: {#tbl-rand-forest-args .cell layout-align=\"center\" tbl-cap='Ejemplos de nombres de argumentos para diferentes funciones de random forest.' hash='06-fitting-models_cache/html/tbl-rand-forest-args_a1992301febb92733db47b7883ac2b88'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Tipo de argumento </th>\n   <th style=\"text-align:left;\"> ranger </th>\n   <th style=\"text-align:left;\"> randomForest </th>\n   <th style=\"text-align:left;\"> sparklyr </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> # predictores muestreo </td>\n   <td style=\"text-align:left;font-family: monospace;\"> mtry </td>\n   <td style=\"text-align:left;font-family: monospace;\"> mtry </td>\n   <td style=\"text-align:left;font-family: monospace;\"> feature_subset_strategy </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> # árboles </td>\n   <td style=\"text-align:left;font-family: monospace;\"> num.trees </td>\n   <td style=\"text-align:left;font-family: monospace;\"> ntree </td>\n   <td style=\"text-align:left;font-family: monospace;\"> num_trees </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> # puntos de datos por división </td>\n   <td style=\"text-align:left;font-family: monospace;\"> min.node.size </td>\n   <td style=\"text-align:left;font-family: monospace;\"> nodesize </td>\n   <td style=\"text-align:left;font-family: monospace;\"> min_instances_per_node </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nEn un esfuerzo por hacer que la especificación de argumentos sea menos complicada, <span class=\"pkg\">parsnip</span> utiliza nombres de argumentos comunes dentro y entre paquetes. @tbl-parsnip-args muestra, para radom forest, qué utilizan los modelos <span class=\"pkg\">parsnip</span>.\n\n\n::: {#tbl-parsnip-args .cell layout-align=\"center\" tbl-cap='Nombres de argumentos de random forest utilizados por parsnip.' hash='06-fitting-models_cache/html/tbl-parsnip-args_6141ad313aab5b559a2350c203cb341d'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Tipo de argumento </th>\n   <th style=\"text-align:left;\"> parsnip </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> # predictores muestreo </td>\n   <td style=\"text-align:left;font-family: monospace;\"> mtry </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> # árboles </td>\n   <td style=\"text-align:left;font-family: monospace;\"> trees </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> # puntos de datos por división </td>\n   <td style=\"text-align:left;font-family: monospace;\"> min_n </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nEs cierto que este es un conjunto más de argumentos para memorizar. Sin embargo, cuando otros tipos de modelos tienen los mismos tipos de argumentos, estos nombres aún se aplican. Por ejemplo, los conjuntos de árboles potenciados también crean una gran cantidad de modelos basados ​​en árboles, por lo que allí también se utilizan `trees`, al igual que `min_n`, etc.\n\nAlgunos de los nombres de los argumentos originales pueden ser bastante jerga. Por ejemplo, para especificar la cantidad de regularización que se utilizará en un modelo glmnet, se utiliza la letra griega `lambda`. Si bien esta notación matemática se usa comúnmente en la literatura estadística, para muchas personas no es obvio qué representa \"lambda\" (especialmente aquellos que consumen los resultados del modelo). Dado que esta es la penalización utilizada en la regularización, <span class=\"pkg\">parsnip</span> estandariza el nombre del argumento `penalty`. De manera similar, el número de vecinos en un modelo KNN se denomina `neighbors` en lugar de `k`. Nuestra regla general al estandarizar los nombres de los argumentos es:\n\n> Si un profesional incluyera estos nombres en un gráfico o tabla, ¿entenderían el nombre las personas que vieran esos resultados?\n\nPara comprender cómo los nombres de los argumentos <span class=\"pkg\">parsnip</span> se asignan a los nombres originales, use el archivo de ayuda para el modelo (disponible a través de `?rand_forest`), así como la función `translate()`:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-glmnet-trans_78db82b91a030819d6c3392a91407d7b'}\n\n```{.r .cell-code}\nrand_forest(trees = 1000, min_n = 5) %>% \n  set_engine(\"ranger\") %>% \n  set_mode(\"regression\") %>% \n  translate()\n## Random Forest Model Specification (regression)\n## \n## Main Arguments:\n##   trees = 1000\n##   min_n = 5\n## \n## Computational engine: ranger \n## \n## Model fit template:\n## ranger::ranger(x = missing_arg(), y = missing_arg(), weights = missing_arg(), \n##     num.trees = 1000, min.node.size = min_rows(~5, x), num.threads = 1, \n##     verbose = FALSE, seed = sample.int(10^5, 1))\n```\n:::\n\n\nLas funciones de modelado en <span class=\"pkg\">parsnip</span> separan los argumentos del modelo en dos categorías:\n\n-   Los *argumentos principales* se utilizan con más frecuencia y tienden a estar disponibles en todos los motores.\n\n-   Los *argumentos del motor* son específicos de un motor en particular o se usan con menos frecuencia.\n\nPor ejemplo, en la traducción del código de random forest anterior, los argumentos `num.threads`, `verbose` y `seed` se agregaron de forma predeterminada. Estos argumentos son específicos de la implementación <span class=\"pkg\">ranger</span> de modelos random forest y no tendrían sentido como argumentos principales. Los argumentos específicos del motor se pueden especificar en `set_engine()`. Por ejemplo, para que la función `ranger::ranger()` imprima más información sobre el ajuste:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-ranger-verb_7290ccfddf1d9f83c0be1af57964a2f8'}\n\n```{.r .cell-code}\nrand_forest(trees = 1000, min_n = 5) %>% \n  set_engine(\"ranger\", verbose = TRUE) %>% \n  set_mode(\"regression\") \n## Random Forest Model Specification (regression)\n## \n## Main Arguments:\n##   trees = 1000\n##   min_n = 5\n## \n## Engine-Specific Arguments:\n##   verbose = TRUE\n## \n## Computational engine: ranger\n```\n:::\n\n\n## Utilizar los Resultados del Modelo\n\nUna vez creado y ajustado el modelo, podemos utilizar los resultados de diversas formas; es posible que queramos trazar, imprimir o examinar de otro modo el resultado del modelo. Varias cantidades se almacenan en un objeto modelo <span class=\"pkg\">parsnip</span>, incluido el modelo ajustado. Esto se puede encontrar en un elemento llamado `fit`, que se puede devolver usando la función `extract_fit_engine()`:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-pluck_dbe447ccfc3d853badc371739469fcaa'}\n\n```{.r .cell-code}\nlm_form_fit %>% extract_fit_engine()\n## \n## Call:\n## stats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data)\n## \n## Coefficients:\n## (Intercept)    Longitude     Latitude  \n##     -302.97        -2.07         2.71\n```\n:::\n\n\nSe pueden aplicar métodos normales a este objeto, como imprimir y trazar:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-pluck-coef_ebacd5e307abe4bb4039622e6b4bc74c'}\n\n```{.r .cell-code}\nlm_form_fit %>% extract_fit_engine() %>% vcov()\n##             (Intercept) Longitude Latitude\n## (Intercept)     207.311   1.57466 -1.42397\n## Longitude         1.575   0.01655 -0.00060\n## Latitude         -1.424  -0.00060  0.03254\n```\n:::\n\n\n::: rmdwarning\nNunca pase el elemento `fit` de un modelo <span class=\"pkg\">parsnip</span> a una función de predicción del modelo, es decir, use `predict(lm_form_fit)` pero *no* use `predict(lm_form_fit$fit)`. Si los datos fueron preprocesados ​​de alguna manera, se generarán predicciones incorrectas (a veces, sin errores). La función de predicción del modelo subyacente no tiene idea de si se ha realizado alguna transformación en los datos antes de ejecutar el modelo. Consulte @sec-parsnip-predictions para obtener más información sobre cómo hacer predicciones.\n:::\n\nUn problema con algunos métodos existentes en base R es que los resultados se almacenan de una manera que puede no ser la más útil. Por ejemplo, el método `summary()` para objetos `lm` se puede utilizar para imprimir los resultados del ajuste del modelo, incluida una tabla con los valores de los parámetros, sus estimaciones de incertidumbre y los valores p. Estos resultados particulares también se pueden guardar:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-lm-param_f26d9c8c50aeb171dd8622b5fa35e664'}\n\n```{.r .cell-code}\nmodel_res <- \n  lm_form_fit %>% \n  extract_fit_engine() %>% \n  summary()\n\n# Se puede acceder a la tabla de coeficientes del modelo mediante el método \"coef\".\nparam_est <- coef(model_res)\nclass(param_est)\n## [1] \"matrix\" \"array\"\nparam_est\n##             Estimate Std. Error t value  Pr(>|t|)\n## (Intercept) -302.974    14.3983  -21.04 3.640e-90\n## Longitude     -2.075     0.1286  -16.13 1.395e-55\n## Latitude       2.710     0.1804   15.02 9.289e-49\n```\n:::\n\n\nHay algunas cosas a tener en cuenta sobre este resultado. Primero, el objeto es una matriz numérica. Lo más probable es que se haya elegido esta estructura de datos, ya que todos los resultados calculados son numéricos y un objeto de matriz se almacena de manera más eficiente que un marco de datos. Esta elección probablemente se hizo a finales de la década de 1970, cuando la eficiencia computacional era extremadamente crítica. En segundo lugar, los datos no numéricos (las etiquetas de los coeficientes) están contenidos en los nombres de las filas. Mantener las etiquetas de los parámetros como nombres de filas es muy coherente con las convenciones del lenguaje S original.\n\nUn siguiente paso razonable podría ser crear una visualización de los valores de los parámetros. Para ello, sería sensato convertir la matriz de parámetros en un marco de datos. Podríamos agregar los nombres de las filas como una columna para que puedan usarse en un gráfico. Sin embargo, observe que varios de los nombres de columnas de matriz existentes no serían nombres de columnas R válidos para marcos de datos ordinarios (por ejemplo, `\"Pr(>|t|)\"`). Otra complicación es la coherencia de los nombres de las columnas. Para objetos `lm`, la columna para el valor p es `\"Pr(>|t|)\"`, pero para otros modelos, se podría usar una prueba diferente y, como resultado, el nombre de la columna sería diferente ( por ejemplo, `\"Pr(>|z|)\"`) y el tipo de prueba se codificaría en el nombre de la columna.\n\nSi bien estos pasos adicionales de formato de datos no son imposibles de superar, son un obstáculo, especialmente porque pueden ser diferentes para distintos tipos de modelos. La matriz no es una estructura de datos altamente reutilizable, principalmente porque limita los datos a ser de un solo tipo (por ejemplo, numéricos). Además, mantener algunos datos en los nombres de las dimensiones también es problemático, ya que esos datos deben extraerse para que sean de uso general.\n\nComo solución, el paquete <span class=\"pkg\">broom</span> puede convertir muchos tipos de objetos modelo en una estructura ordenada. Por ejemplo, usar el método `tidy()` en el modelo lineal produce:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-tidy-lm_7e5ed6b831efab6f492ddac64edb3978'}\n\n```{.r .cell-code}\ntidy(lm_form_fit)\n## # A tibble: 3 × 5\n##   term        estimate std.error statistic  p.value\n##   <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n## 1 (Intercept)  -303.      14.4       -21.0 3.64e-90\n## 2 Longitude      -2.07     0.129     -16.1 1.40e-55\n## 3 Latitude        2.71     0.180      15.0 9.29e-49\n```\n:::\n\n\nLos nombres de las columnas están estandarizados en todos los modelos y no contienen ningún dato adicional (como el tipo de prueba estadística). Los datos que antes estaban contenidos en los nombres de las filas ahora están en una columna llamada `term` (término). Un principio importante en el ecosistema de tidymodels es que una función debe devolver valores que sean *predecibles, consistentes* y *no sorprendentes*.\n\n## Hacer Predicciones {#sec-parsnip-predictions}\n\nOtra área donde <span class=\"pkg\">parsnip</span> difiere de las funciones de modelado R convencionales es el formato de los valores devueltos por `predict()`. Para las predicciones, <span class=\"pkg\">parsnip</span> siempre se ajusta a las siguientes reglas:\n\n1.  Los resultados son siempre un tibble.\n2.  Los nombres de las columnas del tibble siempre son predecibles.\n3.  Siempre hay tantas filas en el tibble como en el conjunto de datos de entrada.\n\nPor ejemplo, cuando se predicen datos numéricos:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-small-pred_e60fb999f3e3488674f6e2a966345abe'}\n\n```{.r .cell-code}\names_test_small <- ames_test %>% slice(1:5)\npredict(lm_form_fit, new_data = ames_test_small)\n## # A tibble: 5 × 1\n##   .pred\n##   <dbl>\n## 1  5.22\n## 2  5.21\n## 3  5.28\n## 4  5.27\n## 5  5.28\n```\n:::\n\n\nEl orden de las filas de las predicciones es siempre el mismo que el de los datos originales.\n\n::: rmdnote\n¿Por qué el punto inicial en algunos de los nombres de las columnas? Algunos argumentos y valores de retorno de tidyverse y tidymodels contienen puntos. Esto es para proteger contra la fusión de datos con nombres duplicados. ¡Hay algunos conjuntos de datos que contienen predictores llamados \"pred\"!\n:::\n\nEstas tres reglas facilitan la combinación de predicciones con los datos originales:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-small-int_bf79ebaf7e689e8d63458ff96b0dca92'}\n\n```{.r .cell-code}\names_test_small %>% \n  select(Sale_Price) %>% \n  bind_cols(predict(lm_form_fit, ames_test_small)) %>% \n  # Agregue intervalos de predicción del 95% a los resultados:\n  bind_cols(predict(lm_form_fit, ames_test_small, type = \"pred_int\")) \n## # A tibble: 5 × 4\n##   Sale_Price .pred .pred_lower .pred_upper\n##        <dbl> <dbl>       <dbl>       <dbl>\n## 1       5.02  5.22        4.91        5.54\n## 2       5.39  5.21        4.90        5.53\n## 3       5.28  5.28        4.97        5.60\n## 4       5.28  5.27        4.96        5.59\n## 5       5.28  5.28        4.97        5.60\n```\n:::\n\n\nLa motivación para la primera regla proviene de algunos paquetes de R que producen tipos de datos diferentes a partir de funciones de predicción. Por ejemplo, el paquete <span class=\"pkg\">ranger</span> es una excelente herramienta para calcular modelos forestales aleatorios. Sin embargo, en lugar de devolver un marco de datos o un vector como salida, devuelve un objeto especializado que tiene múltiples valores incrustados (incluidos los valores predichos). Este es solo un paso más que el analista de datos debe solucionar en sus scripts. Como otro ejemplo, el modelo nativo <span class=\"pkg\">glmnet</span> puede devolver al menos cuatro tipos de salida diferentes para predicciones, dependiendo de los detalles del modelo y las características de los datos. Estos se muestran en @tbl-predict-types.\n\n\n::: {#tbl-predict-types .cell layout-align=\"center\" tbl-cap='Diferentes valores de retorno para tipos de predicción glmnet.' hash='06-fitting-models_cache/html/tbl-predict-types_6c636ea762fcf617eb11a8b6b08efaa5'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Tipo de Predicción </th>\n   <th style=\"text-align:left;\"> Devuelve: </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> numérica </td>\n   <td style=\"text-align:left;\"> matriz numérica </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> clase </td>\n   <td style=\"text-align:left;\"> matriz de texto </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> probabilidad (2 classes) </td>\n   <td style=\"text-align:left;\"> matriz numérica (solo 2do nivel) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> probabilidad (3+ classes) </td>\n   <td style=\"text-align:left;\"> arreglo numérico 3D (todos los niveles) </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nAdemás, los nombres de las columnas de los resultados contienen valores codificados que se asignan a un vector llamado `lambda` dentro del objeto del modelo glmnet. Este excelente método estadístico puede resultar desalentador en la práctica debido a todos los casos especiales que un analista puede encontrar y que requieren código adicional para ser útil.\n\nPara la segunda regla de predicción de tidymodels, los nombres de columnas predecibles para diferentes tipos de predicciones se muestran en @tbl-predictable-column-names.\n\n\n::: {#tbl-predictable-column-names .cell layout-align=\"center\" tbl-cap='El mapeo de tidymodels de tipos de predicción y nombres de columnas.' hash='06-fitting-models_cache/html/tbl-predictable-column-names_3b9db12b9500cd2c68d9fbadc55d92cc'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> tipo de valor </th>\n   <th style=\"text-align:left;\"> nombre(s) de columna(s) </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> numeric </td>\n   <td style=\"text-align:left;font-family: monospace;\"> .pred </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> class </td>\n   <td style=\"text-align:left;font-family: monospace;\"> .pred_class </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> prob </td>\n   <td style=\"text-align:left;font-family: monospace;\"> .pred_{class levels} </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> conf_int </td>\n   <td style=\"text-align:left;font-family: monospace;\"> .pred_lower, .pred_upper </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-family: monospace;\"> pred_int </td>\n   <td style=\"text-align:left;font-family: monospace;\"> .pred_lower, .pred_upper </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nLa tercera regla con respecto al número de filas en la salida es crítica. Por ejemplo, si alguna fila de los datos nuevos contiene valores faltantes, la salida se completará con los resultados faltantes para esas filas. Una ventaja principal de estandarizar la interfaz del modelo y los tipos de predicción en <span class=\"pkg\">parsnip</span> es que, cuando se utilizan diferentes modelos, la sintaxis es idéntica. Supongamos que utilizamos un árbol de decisión para modelar los datos de Ames. Fuera de la especificación del modelo, no hay diferencias significativas en la canalización del código:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-cart_50698a3647472446a017642086075075'}\n\n```{.r .cell-code}\ntree_model <- \n  decision_tree(min_n = 2) %>% \n  set_engine(\"rpart\") %>% \n  set_mode(\"regression\")\n\ntree_fit <- \n  tree_model %>% \n  fit(Sale_Price ~ Longitude + Latitude, data = ames_train)\n\names_test_small %>% \n  select(Sale_Price) %>% \n  bind_cols(predict(tree_fit, ames_test_small))\n## # A tibble: 5 × 2\n##   Sale_Price .pred\n##        <dbl> <dbl>\n## 1       5.02  5.15\n## 2       5.39  5.15\n## 3       5.28  5.32\n## 4       5.28  5.32\n## 5       5.28  5.32\n```\n:::\n\n\nEsto demuestra el beneficio de homogeneizar el proceso de análisis de datos y la sintaxis en diferentes modelos. Permite a los usuarios dedicar su tiempo a los resultados y la interpretación en lugar de tener que centrarse en las diferencias sintácticas entre los paquetes de R.\n\n## Paquetes de Extensión de parsnip\n\nEl paquete <span class=\"pkg\">parsnip</span> en sí contiene interfaces para varios modelos. Sin embargo, para facilitar la instalación y el mantenimiento del paquete, existen otros paquetes tidymodels que tienen definiciones de modelo <span class=\"pkg\">parsnip</span> para otros conjuntos de modelos. El paquete <span class=\"pkg\">discrim</span> tiene definiciones de modelos para el conjunto de técnicas de clasificación llamadas métodos de análisis discriminante (como análisis discriminante lineal o cuadrático). De esta manera, se reducen las dependencias de paquetes necesarias para instalar <span class=\"pkg\">parsnip</span>. Puede encontrar una lista de todos los modelos que se pueden usar con <span class=\"pkg\">parsnip</span> (en diferentes paquetes que están en CRAN) en <https://www.tidymodels.org/find/>.\n\n## Crear especificaciones de modelo {#sec-parsnip-addin}\n\nPuede resultar tedioso escribir muchas especificaciones de modelos o recordar cómo escribir el código para generarlas. El paquete <span class=\"pkg\">parsnip</span> incluye un complemento RStudio[^06-fitting-models-3] que puede ayudar. Ya sea eligiendo este complemento en el menú de la barra de herramientas *Addins* o ejecutando el código:\n\n[^06-fitting-models-3]: <https://rstudio.github.io/rstudioaddins/>\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-add-in_ed25fe953a8de10db798595c62157d21'}\n\n```{.r .cell-code}\nparsnip_addin()\n```\n:::\n\n\nabrirá una ventana en el panel Viewer de RStudio IDE con una lista de posibles modelos para cada modo de modelo. Estos se pueden escribir en el panel de código fuente.\n\nLa lista de modelos incluye modelos de los paquetes de extensión <span class=\"pkg\">parsnip</span> y <span class=\"pkg\">parsnip</span> que están en CRAN.\n\n## Resumen del capítulo {#sec-models-summary}\n\nEste capítulo presentó el paquete <span class=\"pkg\">parsnip</span>, que proporciona una interfaz común para modelos en todos los paquetes R utilizando una sintaxis estándar. La interfaz y los objetos resultantes tienen una estructura predecible.\n\nEl código para modelar los datos de Ames que usaremos en el futuro es:\n\n\n::: {.cell layout-align=\"center\" hash='06-fitting-models_cache/html/models-summary_7ac8ab209d3d3c24fc4d4d71b065e200'}\n\n```{.r .cell-code}\nlibrary(tidymodels)\ndata(ames)\names <- mutate(ames, Sale_Price = log10(Sale_Price))\n\nset.seed(502)\names_split <- initial_split(ames, prop = 0.80, strata = Sale_Price)\names_train <- training(ames_split)\names_test  <-  testing(ames_split)\n\nlm_model <- linear_reg() %>% set_engine(\"lm\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}