{
  "hash": "130027053a2c7d7118b23af03b63b302",
  "result": {
    "markdown": "\n\n\n# Ensembles of Models {#sec-ensembles}\n\nA model ensemble, where the predictions of multiple single learners are aggregated to make one prediction, can produce a high-performance final model. The most popular methods for creating ensemble models are bagging [@breiman1996bagging], random forest [@ho1995random; @breiman2001random], and boosting [@freund1997decision]. Each of these methods combines the predictions from multiple versions of the same type of model (e.g., classifications trees). However, one of the earliest methods for creating ensembles is *model stacking* [@wolpert1992stacked; @breiman1996stacked].\n\n::: rmdnote\nModel stacking combines the predictions for multiple models of any type. For example, a logistic regression, classification tree, and support vector machine can be included in a stacking ensemble.\n:::\n\nThis chapter shows how to stack predictive models using the <span class=\"pkg\">stacks</span> package. We'll re-use the results from [Chapter @sec-workflow-sets] where multiple models were evaluated to predict the compressive strength of concrete mixtures.\n\nThe process of building a stacked ensemble is:\n\n1.  Assemble the training set of hold-out predictions (produced via resampling).\n2.  Create a model to blend these predictions.\n3.  For each member of the ensemble, fit the model on the original training set.\n\nIn subsequent sections, we'll describe this process. However, before proceeding, we'll clarify some nomenclature for the variations of what \"the model\" can mean. This can quickly become an overloaded term when we are working on a complex modeling analysis! Let's consider the multilayer perceptron (MLP) model (a.k.a. neural network) created in [Chapter @sec-workflow-sets].\n\nIn general, we'll talk about an MLP model as the *type* of model. Linear regression and support vector machines are other model types.\n\nTuning parameters are an important aspect of a model. Back in [Chapter @sec-workflow-sets], the MLP model was tuned over 25 tuning parameter values. In the previous chapters, we've called these *candidate tuning parameter* values or *model configurations*. In literature on ensembling these have also been called the base models.\n\n::: rmdnote\nWe'll use the term *candidate members* to describe the possible model configurations (of all model types) that might be included in the stacking ensemble.\n:::\n\nThis means that a stacking model can include different types of models (e.g., trees and neural networks) as well as different configurations of the same model (e.g., trees with different depths).\n\n## Creating the Training Set for Stacking {#sec-data-stack}\n\nThe first step for building a stacked ensemble relies on the assessment set predictions from a resampling scheme with multiple splits. For each data point in the training set, stacking requires an out-of-sample prediction of some sort. For regression models, this is the predicted outcome. For classification models, the predicted classes or probabilities are available for use, although the latter contains more information than the hard class predictions. For a set of models, a data set is assembled where rows are the training set samples and columns are the out-of-sample predictions from the set of multiple models.\n\nBack in [Chapter @sec-workflow-sets], we used five repeats of 10-fold cross-validation to resample the data. This resampling scheme generates five assessment set predictions for each training set sample. Multiple out-of-sample predictions can occur in several other resampling techniques (e.g., bootstrapping). For the purpose of stacking, any replicate predictions for a data point in the training set are averaged so that there is a single prediction per training set sample per candidate member.\n\n::: rmdnote\nSimple validation sets can also be used with stacking since tidymodels considers this to be a single resample.\n:::\n\nFor the concrete example, the training set used for model stacking has columns for all of the candidate tuning parameter results. @tbl-ensemble-candidate-preds presents the first six rows and selected columns.\n\n\n::: {#tbl-ensemble-candidate-preds .cell layout-align=\"center\" tbl-cap='Predictions from candidate tuning parameter configurations.' hash='20-ensemble-models_cache/html/tbl-ensemble-candidate-preds_5bcca83b1787fdf6be68fb86b84eee20'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n<tr>\n<th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"1\"></th>\n<th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"7\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">Ensemble Candidate Predictions</div></th>\n</tr>\n  <tr>\n   <th style=\"text-align:center;text-align: center;\"> Sample # </th>\n   <th style=\"text-align:center;text-align: center;\"> Bagged Tree </th>\n   <th style=\"text-align:center;text-align: center;\"> MARS 1 </th>\n   <th style=\"text-align:center;text-align: center;\"> MARS 2 </th>\n   <th style=\"text-align:center;text-align: center;\"> Cubist 1 </th>\n   <th style=\"text-align:center;text-align: center;\"> ... </th>\n   <th style=\"text-align:center;text-align: center;\"> Cubist 25 </th>\n   <th style=\"text-align:center;text-align: center;\"> ... </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 1 </td>\n   <td style=\"text-align:center;\"> 25.18 </td>\n   <td style=\"text-align:center;\"> 17.92 </td>\n   <td style=\"text-align:center;\"> 17.15 </td>\n   <td style=\"text-align:center;\"> 17.79 </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> 17.82 </td>\n   <td style=\"text-align:center;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 2 </td>\n   <td style=\"text-align:center;\"> 5.18 </td>\n   <td style=\"text-align:center;\"> -1.77 </td>\n   <td style=\"text-align:center;\"> -0.73 </td>\n   <td style=\"text-align:center;\"> 2.83 </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> 3.87 </td>\n   <td style=\"text-align:center;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 3 </td>\n   <td style=\"text-align:center;\"> 9.71 </td>\n   <td style=\"text-align:center;\"> 7.26 </td>\n   <td style=\"text-align:center;\"> 5.91 </td>\n   <td style=\"text-align:center;\"> 6.31 </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> 8.60 </td>\n   <td style=\"text-align:center;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 4 </td>\n   <td style=\"text-align:center;\"> 25.21 </td>\n   <td style=\"text-align:center;\"> 20.93 </td>\n   <td style=\"text-align:center;\"> 21.52 </td>\n   <td style=\"text-align:center;\"> 23.72 </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> 21.61 </td>\n   <td style=\"text-align:center;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 5 </td>\n   <td style=\"text-align:center;\"> 6.33 </td>\n   <td style=\"text-align:center;\"> 1.53 </td>\n   <td style=\"text-align:center;\"> 0.15 </td>\n   <td style=\"text-align:center;\"> 3.60 </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> 4.57 </td>\n   <td style=\"text-align:center;\">  </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 6 </td>\n   <td style=\"text-align:center;\"> 7.88 </td>\n   <td style=\"text-align:center;\"> 4.88 </td>\n   <td style=\"text-align:center;\"> 1.74 </td>\n   <td style=\"text-align:center;\"> 7.69 </td>\n   <td style=\"text-align:center;\">  </td>\n   <td style=\"text-align:center;\"> 7.55 </td>\n   <td style=\"text-align:center;\">  </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nThere is a single column for the bagged tree model since it has no tuning parameters. Also, recall that MARS was tuned over a single parameter (the product degree) with two possible configurations, so this model is represented by two columns. Most of the other models have 25 corresponding columns, as shown for Cubist in this example.\n\n::: rmdwarning\nFor classification models, the candidate prediction columns would be predicted class probabilities. Since these columns add to one for each model, the probabilities for one of the classes can be left out.\n:::\n\nTo summarize where we are so far, the first step to stacking is to assemble the assessment set predictions for the training set from each candidate model. We can use these assessment set predictions to move forward and build a stacked ensemble.\n\nTo start ensembling with the <span class=\"pkg\">stacks</span> package, create an empty data stack using the `stacks()` function and then add candidate models. Recall that we used workflow sets to fit a wide variety of models to these data. We'll use the racing results:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-race_b69b3c5476a1ceb17a67e7f46d359df6'}\n\n```{.r .cell-code}\nrace_results\n## # A workflow set/tibble: 12 × 4\n##   wflow_id    info             option    result   \n##   <chr>       <list>           <list>    <list>   \n## 1 MARS        <tibble [1 × 4]> <opts[3]> <race[+]>\n## 2 CART        <tibble [1 × 4]> <opts[3]> <race[+]>\n## 3 CART_bagged <tibble [1 × 4]> <opts[3]> <rsmp[+]>\n## 4 RF          <tibble [1 × 4]> <opts[3]> <race[+]>\n## 5 boosting    <tibble [1 × 4]> <opts[3]> <race[+]>\n## 6 Cubist      <tibble [1 × 4]> <opts[3]> <race[+]>\n## # ℹ 6 more rows\n```\n:::\n\n\nIn this case, our syntax is:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-data-stack_954077dca446878af024ec52e09fda68'}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(stacks)\ntidymodels_prefer()\n\nconcrete_stack <- \n  stacks() %>% \n  add_candidates(race_results)\n\nconcrete_stack\n## # A data stack with 12 model definitions and 18 candidate members:\n## #   MARS: 1 model configuration\n## #   CART: 1 model configuration\n## #   CART_bagged: 1 model configuration\n## #   RF: 1 model configuration\n## #   boosting: 1 model configuration\n## #   Cubist: 1 model configuration\n## #   SVM_radial: 1 model configuration\n## #   SVM_poly: 1 model configuration\n## #   KNN: 3 model configurations\n## #   neural_network: 1 model configuration\n## #   full_quad_linear_reg: 5 model configurations\n## #   full_quad_KNN: 1 model configuration\n## # Outcome: compressive_strength (numeric)\n```\n:::\n\n\nRecall that racing methods (@sec-racing) are more efficient since they might not evaluate all configurations on all resamples. Stacking requires that all candidate members have the complete set of resamples. `add_candidates()` includes only the model configurations that have complete results.\n\n::: rmdnote\nWhy use the racing results instead of the full set of candidate models contained in `grid_results`? Either can be used. We found better performance for these data using the racing results. This might be due to the racing method pre-selecting the best model(s) from the larger grid.\n:::\n\nIf we had not used the <span class=\"pkg\">workflowsets</span> package, objects from the <span class=\"pkg\">tune</span> and <span class=\"pkg\">finetune</span> could also be passed to `add_candidates()`. This can include both grid and iterative search objects.\n\n## Blend the Predictions {#sec-blend-predictions}\n\nThe training set predictions and the corresponding observed outcome data are used to create a *meta-learning model* where the assessment set predictions are the predictors of the observed outcome data. Meta-learning can be accomplished using any model. The most commonly used model is a regularized generalized linear model, which encompasses linear, logistic, and multinomial models. Specifically, regularization via the lasso penalty [@lasso], which uses shrinkage to pull points toward a central value, has several advantages:\n\n-   Using the lasso penalty can remove candidates (and sometimes whole model types) from the ensemble.\n-   The correlation between ensemble candidates tends to be very high, and regularization helps alleviate this issue.\n\n@breiman1996stacked also suggested that, when a linear model is used to blend the predictions, it might be helpful to constrain the blending coefficients to be nonnegative. We have generally found this to be good advice and it is the default for the <span class=\"pkg\">stacks</span> package (but it can be changed via an optional argument).\n\nSince our outcome is numeric, linear regression is used for the metamodel. Fitting the metamodel is as straightforward as using:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-initial-blend_7e4d13223ca59ac9aaca0c8b70961179'}\n\n```{.r .cell-code}\nset.seed(2001)\nens <- blend_predictions(concrete_stack)\n```\n:::\n\n\nThis evaluates the meta-learning model over a predefined grid of lasso penalty values and uses an internal resampling method to determine the best value. The `autoplot()` method, shown in @fig-stacking-autoplot, helps us understand if the default penalization method was sufficient:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-initial-blend-plot_c61ba53afcecd4bfab9dabb8e719c8aa'}\n\n```{.r .cell-code}\nautoplot(ens)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/fig-stacking-autoplot_a6e00aa7a3e85a72f6c8bfe94b805921'}\n::: {.cell-output-display}\n![Results of using the `autoplot()` method on the blended stacks object](20-ensemble-models_files/figure-html/fig-stacking-autoplot-1.png){#fig-stacking-autoplot fig-align='center' fig-alt='The results of using the `autoplot()` method on the blended stacks object.' width=672}\n:::\n:::\n\n\nThe top panel of @fig-stacking-autoplot shows the average number of candidate ensemble members retained by the meta-learning model. We can see that the number of members is fairly constant and, as it increases, the RMSE also increases.\n\nThe default range may not have served us well here. To evaluate the meta-learning model with larger penalties, let's pass an additional option:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-second-blend_43416a686b925c7a6cdb1a1c587e5c85'}\n\n```{.r .cell-code}\nset.seed(2002)\nens <- blend_predictions(concrete_stack, penalty = 10^seq(-2, -0.5, length = 20))\n```\n:::\n\n\nNow, in @fig-stacking-autoplot-redo, we see a range where the ensemble model becomes worse than with our first blend (but not by much). The $R^2$ values increase with more members and larger penalties.\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-autoplot-calc_ee9a2e8c837e8ae68ed79b26bc84fbd9'}\n\n```{.r .cell-code}\nautoplot(ens)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/fig-stacking-autoplot-redo_1e4702636839e47adc0cb7296e9c385f'}\n::: {.cell-output-display}\n![The results of using the `autoplot()` method on the updated blended stacks object](20-ensemble-models_files/figure-html/fig-stacking-autoplot-redo-1.png){#fig-stacking-autoplot-redo fig-align='center' fig-alt='The results of using the `autoplot()` method on the updated blended stacks object.' width=672}\n:::\n:::\n\n\nWhen blending predictions using a regression model, it is common to constrain the blending parameters to be nonnegative. For these data, this constraint has the effect of eliminating many of the potential ensemble members; even at fairly low penalties, the ensemble is limited to a fraction of the original eighteen.\n\nThe penalty value associated with the smallest RMSE was 0.01. Printing the object shows the details of the meta-learning model:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-second-blend-print_25fa89ad9d8ff9c218f9a038e15a3ac3'}\n\n```{.r .cell-code}\nens\n## ── A stacked ensemble model ─────────────────────────────────────\n## \n## \n## Out of 18 possible candidate members, the ensemble retained 5.\n## \n## Penalty: 0.01.\n## \n## Mixture: 1.\n## \n## \n## The 5 highest weighted members are:\n## # A tibble: 5 × 3\n##   member                    type           weight\n##   <chr>                     <chr>           <dbl>\n## 1 boosting_1_16             boost_tree    0.712  \n## 2 neural_network_1_17       mlp           0.208  \n## 3 Cubist_1_25               cubist_rules  0.0759 \n## 4 full_quad_linear_reg_1_16 linear_reg    0.0161 \n## 5 CART_1_05                 decision_tree 0.00476\n## \n## Members have not yet been fitted with `fit_members()`.\n```\n:::\n\n\n\n\nThe regularized linear regression meta-learning model contained five blending coefficients across five types of models. The `autoplot()` method can be used again to show the contributions of each model type, to produce @fig-blending-weights.\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-blending-weights_e28c16cf638ce2f666e2f932e29c9772'}\n\n```{.r .cell-code}\nautoplot(ens, \"weights\") +\n  geom_text(aes(x = weight + 0.01, label = model), hjust = 0) + \n  theme(legend.position = \"none\") +\n  lims(x = c(-0.01, 0.8))\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/fig-blending-weights_d300184506b672e799d76fcd9348557d'}\n::: {.cell-output-display}\n![Blending coefficients for the stacking ensemble](20-ensemble-models_files/figure-html/fig-blending-weights-1.png){#fig-blending-weights fig-align='center' fig-alt='blending_alt' width=672}\n:::\n:::\n\n\nThe boosted tree and neural network models have the largest contributions to the ensemble. For this ensemble, the outcome is predicted with the equation:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-equation_30060f5a9dc4938afe50c2c42a688fc0'}\n\n\\begin{align}\n \\text{ensemble prediction} &=-0.62 \\\\\n\t+&0.71 \\times \\text{boost tree prediction} \\notag \\\\\n\t+&0.21 \\times \\text{mlp prediction} \\notag \\\\\n\t+&0.076 \\times \\text{cubist rules prediction} \\notag \\\\\n\t+&0.016 \\times \\text{linear reg prediction} \\notag \\\\\n\t+&0.0048 \\times \\text{decision tree prediction} \\notag\n\\end{align}\n:::\n\n\nwhere the predictors in the equation are the predicted compressive strength values from those models.\n\n## Fit the Member Models {#sec-fit-members}\n\nThe ensemble contains five candidate members, and we now know how their predictions can be blended into a final prediction for the ensemble. However, these individual model fits have not yet been created. To be able to use the stacking model, five additional model fits are required. These use the entire training set with the original predictors.\n\nThe five models to be fit are:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-show-members_e58167a95049fa46aef82a237853de5d'}\n- boosting: number of trees = 1800, minimal node size = 25, tree depth = 4, learning rate = 0.109, minimum loss reduction = 9.84e-10, and proportion of observations sampled = 0.85\n\n- Cubist: number of committees = 98 and number of nearest neighbors = 2\n\n- CART: cost-complexity parameter = 5e-08 and minimal node size = 3\n\n- linear regression (quadratic features): amount of regularization = 6.28e-09 and proportion of lasso penalty = 0.636\n\n- neural network: number of hidden units = 26, amount of regularization = 0.0149, and number of epochs = 203\n:::\n\n\nThe <span class=\"pkg\">stacks</span> package has a function, `fit_members()`, that trains and returns these models:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-fit-members_2714c93d9fab59933c8d181256c0446e'}\n\n```{.r .cell-code}\nens <- fit_members(ens)\n```\n:::\n\n\nThis updates the stacking object with the fitted workflow objects for each member. At this point, the stacking model can be used for prediction.\n\n## Test Set Results\n\nSince the blending process used resampling, we can estimate that the ensemble with five members had an estimated RMSE of 4.09. Recall from [Chapter @sec-workflow-sets] that the best boosted tree had a test set RMSE of 3.46. How will the ensemble model compare on the test set? We can `predict()` to find out:\n\n\n::: {.cell layout-align=\"center\" hash='20-ensemble-models_cache/html/ensembles-test-set_7669246b644b1f3439327f86657dab75'}\n\n```{.r .cell-code}\nreg_metrics <- metric_set(rmse, rsq)\nens_test_pred <- \n  predict(ens, concrete_test) %>% \n  bind_cols(concrete_test)\n\nens_test_pred %>% \n  reg_metrics(compressive_strength, .pred)\n## # A tibble: 2 × 3\n##   .metric .estimator .estimate\n##   <chr>   <chr>          <dbl>\n## 1 rmse    standard       3.37 \n## 2 rsq     standard       0.956\n```\n:::\n\n\nThis is moderately better than our best single model. It is fairly common for stacking to produce incremental benefits when compared to the best single model.\n\n## Chapter Summary {#sec-ensembles-summary}\n\nThis chapter demonstrated how to combine different models into an ensemble for better predictive performance. The process of creating the ensemble can automatically eliminate candidate models to find a small subset that improves performance. The <span class=\"pkg\">stacks</span> package has a fluent interface for combining resampling and tuning results into a meta-model.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}